{"version":3,"file":"queue.js","sourceRoot":"","sources":["../../src/queue.ts"],"names":[],"mappings":"AAEA,MAAM,SAAS,GAAG,GAAU,EAAE;IAC5B,IAAI,WAAW,GAAqB,OAAO,CAAC,OAAO,EAAE,CAAC;IACtD,qDAAqD;IACrD,qDAAqD;IACrD,OAAO,CAAC,EAAE,EAAE,EAAE,CACZ,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QAC9B,WAAW,GAAG,WAAW;aACtB,IAAI,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC;aAChB,IAAI,CAAC,OAAO,CAAC;aACb,KAAK,CAAC,MAAM,CAAC,CAAC;IACnB,CAAC,CAAC,CAAC;AACP,CAAC,CAAC;AAEF,MAAM,UAAU,QAAQ,CAAC,OAAgB;IACvC,IAAI,OAAO,EAAE;QACX,OAAO,SAAS,EAAE,CAAC;KACpB;IACD,OAAO,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC;AACtB,CAAC","sourcesContent":["type Queue = <T>(fn: () => Promise<T>) => Promise<T>;\r\n\r\nconst makeQueue = (): Queue => {\r\n  let currentTask: Promise<unknown> = Promise.resolve();\r\n  // create a new promise so that errors can be bubbled\r\n  // up to the caller without being caught by the queue\r\n  return (fn) =>\r\n    new Promise((resolve, reject) => {\r\n      currentTask = currentTask\r\n        .then(() => fn())\r\n        .then(resolve)\r\n        .catch(reject);\r\n    });\r\n};\r\n\r\nexport function getQueue(enabled: boolean): Queue {\r\n  if (enabled) {\r\n    return makeQueue();\r\n  }\r\n  return (fn) => fn();\r\n}\r\n"]}