{"version":3,"file":"definitions.js","sourceRoot":"","sources":["../../src/definitions.ts"],"names":[],"mappings":"AAuDA;;GAEG;AACH,MAAM,CAAN,IAAY,QAgBX;AAhBD,WAAY,QAAQ;IAClB;;;OAGG;IACH,qEAAuB,CAAA;IACvB;;;OAGG;IACH,mEAAsB,CAAA;IACtB;;;OAGG;IACH,yEAAyB,CAAA;AAC3B,CAAC,EAhBW,QAAQ,KAAR,QAAQ,QAgBnB;AAED;;GAEG;AACH,MAAM,CAAN,IAAY,kBAgBX;AAhBD,WAAY,kBAAkB;IAC5B;;;OAGG;IACH,2GAAgC,CAAA;IAChC;;;OAGG;IACH,mGAA4B,CAAA;IAC5B;;;OAGG;IACH,6GAAiC,CAAA;AACnC,CAAC,EAhBW,kBAAkB,KAAlB,kBAAkB,QAgB7B","sourcesContent":["import type { PluginListenerHandle } from '@capacitor/core';\r\n\r\nimport type { DisplayStrings } from './config';\r\n\r\nexport interface InitializeOptions {\r\n  /**\r\n   * If your app doesn't use Bluetooth scan results to derive physical\r\n   * location information, you can strongly assert that your app\r\n   * doesn't derive physical location. (Android only)\r\n   * Requires adding 'neverForLocation' to AndroidManifest.xml\r\n   * https://developer.android.com/guide/topics/connectivity/bluetooth/permissions#assert-never-for-location\r\n   * @default false\r\n   */\r\n  androidNeverForLocation?: boolean;\r\n}\r\n\r\nexport interface RequestBleDeviceOptions {\r\n  /**\r\n   * Filter devices by service UUIDs.\r\n   * UUIDs have to be specified as 128 bit UUID strings,\r\n   * e.g. ['0000180d-0000-1000-8000-00805f9b34fb']\r\n   * There is a helper function to convert numbers to UUIDs.\r\n   * e.g. [numberToUUID(0x180f)]. (see [UUID format](#uuid-format))\r\n   */\r\n  services?: string[];\r\n  /**\r\n   * Filter devices by name\r\n   */\r\n  name?: string;\r\n  /**\r\n   * Filter devices by name prefix\r\n   */\r\n  namePrefix?: string;\r\n  /**\r\n   * For **web**, all services that will be used have to be listed under services or optionalServices,\r\n   * e.g. [numberToUUID(0x180f)] (see [UUID format](#uuid-format))\r\n   */\r\n  optionalServices?: string[];\r\n  /**\r\n   * Normally scans will discard the second and subsequent advertisements from a single device.\r\n   * If you need to receive them, set allowDuplicates to true (only applicable in `requestLEScan`).\r\n   * (default: false)\r\n   */\r\n  allowDuplicates?: boolean;\r\n  /**\r\n   * Android scan mode (default: ScanMode.SCAN_MODE_BALANCED)\r\n   */\r\n  scanMode?: ScanMode;\r\n  /**\r\n   * Allow scanning for devices with a specific manufacturer data\r\n   * https://developer.mozilla.org/en-US/docs/Web/API/Bluetooth/requestDevice#manufacturerdata\r\n   */\r\n  manufacturerData?: { companyIdentifier: number; dataPrefix?: Uint8Array; mask?: Uint8Array }[];\r\n}\r\n\r\n/**\r\n * Android scan mode\r\n */\r\nexport enum ScanMode {\r\n  /**\r\n   * Perform Bluetooth LE scan in low power mode. This mode is enforced if the scanning application is not in foreground.\r\n   * https://developer.android.com/reference/android/bluetooth/le/ScanSettings#SCAN_MODE_LOW_POWER\r\n   */\r\n  SCAN_MODE_LOW_POWER = 0,\r\n  /**\r\n   * Perform Bluetooth LE scan in balanced power mode. (default) Scan results are returned at a rate that provides a good trade-off between scan frequency and power consumption.\r\n   * https://developer.android.com/reference/android/bluetooth/le/ScanSettings#SCAN_MODE_BALANCED\r\n   */\r\n  SCAN_MODE_BALANCED = 1,\r\n  /**\r\n   * Scan using highest duty cycle. It's recommended to only use this mode when the application is running in the foreground.\r\n   * https://developer.android.com/reference/android/bluetooth/le/ScanSettings#SCAN_MODE_LOW_LATENCY\r\n   */\r\n  SCAN_MODE_LOW_LATENCY = 2,\r\n}\r\n\r\n/**\r\n * Android connection priority used in `requestConnectionPriority`\r\n */\r\nexport enum ConnectionPriority {\r\n  /**\r\n   * Use the connection parameters recommended by the Bluetooth SIG. This is the default value if no connection parameter update is requested.\r\n   * https://developer.android.com/reference/android/bluetooth/BluetoothGatt#CONNECTION_PRIORITY_BALANCED\r\n   */\r\n  CONNECTION_PRIORITY_BALANCED = 0,\r\n  /**\r\n   * Request a high priority, low latency connection. An application should only request high priority connection parameters to transfer large amounts of data over LE quickly. Once the transfer is complete, the application should request CONNECTION_PRIORITY_BALANCED connection parameters to reduce energy use.\r\n   * https://developer.android.com/reference/android/bluetooth/BluetoothGatt#CONNECTION_PRIORITY_HIGH\r\n   */\r\n  CONNECTION_PRIORITY_HIGH = 1,\r\n  /**\r\n   * Request low power, reduced data rate connection parameters.\r\n   * https://developer.android.com/reference/android/bluetooth/BluetoothGatt#CONNECTION_PRIORITY_LOW_POWER\r\n   */\r\n  CONNECTION_PRIORITY_LOW_POWER = 2,\r\n}\r\n\r\nexport interface BleDevice {\r\n  /**\r\n   * ID of the device, which will be needed for further calls.\r\n   * On **Android** this is the BLE MAC address.\r\n   * On **iOS** and **web** it is an identifier.\r\n   */\r\n  deviceId: string;\r\n  /**\r\n   * Name of the peripheral device.\r\n   */\r\n  name?: string;\r\n  uuids?: string[];\r\n}\r\n\r\nexport interface DeviceIdOptions {\r\n  deviceId: string;\r\n}\r\nexport interface TimeoutOptions {\r\n  /**\r\n   * Timeout in milliseconds for plugin call.\r\n   * Default is 10000 for `connect` and 5000 for other plugin methods.\r\n   */\r\n  timeout?: number;\r\n}\r\n\r\nexport interface RequestConnectionPriorityOptions extends DeviceIdOptions {\r\n  connectionPriority: ConnectionPriority;\r\n}\r\n\r\nexport interface GetDevicesOptions {\r\n  deviceIds: string[];\r\n}\r\n\r\nexport interface GetConnectedDevicesOptions {\r\n  services: string[];\r\n}\r\n\r\nexport interface BleService {\r\n  readonly uuid: string;\r\n  readonly characteristics: BleCharacteristic[];\r\n}\r\n\r\nexport interface BleDescriptor {\r\n  readonly uuid: string;\r\n}\r\n\r\nexport interface BleCharacteristic {\r\n  readonly uuid: string;\r\n  readonly properties: BleCharacteristicProperties;\r\n  readonly descriptors: BleDescriptor[];\r\n}\r\n\r\nexport interface BleCharacteristicProperties {\r\n  readonly broadcast: boolean;\r\n  readonly read: boolean;\r\n  readonly writeWithoutResponse: boolean;\r\n  readonly write: boolean;\r\n  readonly notify: boolean;\r\n  readonly indicate: boolean;\r\n  readonly authenticatedSignedWrites: boolean;\r\n  readonly reliableWrite?: boolean;\r\n  readonly writableAuxiliaries?: boolean;\r\n  readonly extendedProperties?: boolean;\r\n  readonly notifyEncryptionRequired?: boolean;\r\n  readonly indicateEncryptionRequired?: boolean;\r\n}\r\n\r\nexport interface BleServices {\r\n  services: BleService[];\r\n}\r\n\r\nexport interface ReadOptions {\r\n  deviceId: string;\r\n  service: string;\r\n  characteristic: string;\r\n}\r\n\r\nexport interface ReadDescriptorOptions {\r\n  deviceId: string;\r\n  service: string;\r\n  characteristic: string;\r\n  descriptor: string;\r\n}\r\n\r\nexport type Data = DataView | string;\r\n\r\nexport interface WriteOptions {\r\n  deviceId: string;\r\n  service: string;\r\n  characteristic: string;\r\n  /**\r\n   * android, ios: string\r\n   * web: DataView\r\n   */\r\n  value: Data;\r\n}\r\n\r\nexport interface WriteDescriptorOptions {\r\n  deviceId: string;\r\n  service: string;\r\n  characteristic: string;\r\n  descriptor: string;\r\n  /**\r\n   * android, ios: string\r\n   * web: DataView\r\n   */\r\n  value: Data;\r\n}\r\n\r\nexport interface BooleanResult {\r\n  value: boolean;\r\n}\r\n\r\nexport interface GetDevicesResult {\r\n  devices: BleDevice[];\r\n}\r\n\r\nexport interface GetMtuResult {\r\n  value: number;\r\n}\r\n\r\nexport interface ReadRssiResult {\r\n  value: string;\r\n}\r\n\r\nexport interface ReadResult {\r\n  /**\r\n   * android, ios: string\r\n   * web: DataView\r\n   */\r\n  value?: Data;\r\n}\r\n\r\nexport interface ScanResultInternal<T = Data> {\r\n  device: BleDevice;\r\n  localName?: string;\r\n  rssi?: number;\r\n  txPower?: number;\r\n  manufacturerData?: { [key: string]: T };\r\n  serviceData?: { [key: string]: T };\r\n  uuids?: string[];\r\n  rawAdvertisement?: T;\r\n}\r\n\r\nexport interface ScanResult {\r\n  /**\r\n   * The peripheral device that was found in the scan.\r\n   * **Android** and **web**: `device.name` is always identical to `localName`.\r\n   * **iOS**: `device.name` is identical to `localName` the first time a device is discovered, but after connecting `device.name` is the cached GAP name in subsequent scans.\r\n   */\r\n  device: BleDevice;\r\n  /**\r\n   * The name of the peripheral device from the advertisement data.\r\n   */\r\n  localName?: string;\r\n  /**\r\n   * Received Signal Strength Indication.\r\n   */\r\n  rssi?: number;\r\n  /**\r\n   * Transmit power in dBm. A value of 127 indicates that it is not available.\r\n   */\r\n  txPower?: number;\r\n  /**\r\n   * Manufacturer data, key is a company identifier and value is the data.\r\n   */\r\n  manufacturerData?: { [key: string]: DataView };\r\n  /**\r\n   * Service data, key is a service UUID and value is the data.\r\n   */\r\n  serviceData?: { [key: string]: DataView };\r\n  /**\r\n   * Advertised services.\r\n   */\r\n  uuids?: string[];\r\n  /**\r\n   * Raw advertisement data (**Android** only).\r\n   */\r\n  rawAdvertisement?: DataView;\r\n}\r\n\r\nexport interface BluetoothLePlugin {\r\n  initialize(options?: InitializeOptions): Promise<void>;\r\n  isEnabled(): Promise<BooleanResult>;\r\n  requestEnable(): Promise<void>;\r\n  enable(): Promise<void>;\r\n  disable(): Promise<void>;\r\n  startEnabledNotifications(): Promise<void>;\r\n  stopEnabledNotifications(): Promise<void>;\r\n  isLocationEnabled(): Promise<BooleanResult>;\r\n  openLocationSettings(): Promise<void>;\r\n  openBluetoothSettings(): Promise<void>;\r\n  openAppSettings(): Promise<void>;\r\n  setDisplayStrings(displayStrings: DisplayStrings): Promise<void>;\r\n  requestDevice(options?: RequestBleDeviceOptions): Promise<BleDevice>;\r\n  requestLEScan(options?: RequestBleDeviceOptions): Promise<void>;\r\n  stopLEScan(): Promise<void>;\r\n  getDevices(options: GetDevicesOptions): Promise<GetDevicesResult>;\r\n  getConnectedDevices(options: GetConnectedDevicesOptions): Promise<GetDevicesResult>;\r\n  getBondedDevices(): Promise<GetDevicesResult>;\r\n  addListener(\r\n    eventName: 'onEnabledChanged',\r\n    listenerFunc: (result: BooleanResult) => void,\r\n  ): Promise<PluginListenerHandle>;\r\n  addListener(eventName: string, listenerFunc: (event: ReadResult) => void): Promise<PluginListenerHandle>;\r\n  addListener(\r\n    eventName: 'onScanResult',\r\n    listenerFunc: (result: ScanResultInternal) => void,\r\n  ): Promise<PluginListenerHandle>;\r\n  connect(options: DeviceIdOptions & TimeoutOptions): Promise<void>;\r\n  createBond(options: DeviceIdOptions & TimeoutOptions): Promise<void>;\r\n  isBonded(options: DeviceIdOptions): Promise<BooleanResult>;\r\n  disconnect(options: DeviceIdOptions): Promise<void>;\r\n  getServices(options: DeviceIdOptions): Promise<BleServices>;\r\n  discoverServices(options: DeviceIdOptions): Promise<void>;\r\n  getMtu(options: DeviceIdOptions): Promise<GetMtuResult>;\r\n  requestConnectionPriority(options: RequestConnectionPriorityOptions): Promise<void>;\r\n  readRssi(options: DeviceIdOptions): Promise<ReadRssiResult>;\r\n  read(options: ReadOptions & TimeoutOptions): Promise<ReadResult>;\r\n  write(options: WriteOptions & TimeoutOptions): Promise<void>;\r\n  writeWithoutResponse(options: WriteOptions & TimeoutOptions): Promise<void>;\r\n  readDescriptor(options: ReadDescriptorOptions & TimeoutOptions): Promise<ReadResult>;\r\n  writeDescriptor(options: WriteDescriptorOptions & TimeoutOptions): Promise<void>;\r\n  startNotifications(options: ReadOptions): Promise<void>;\r\n  stopNotifications(options: ReadOptions): Promise<void>;\r\n}\r\n"]}